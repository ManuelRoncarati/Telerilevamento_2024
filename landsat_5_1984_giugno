# richiamiamo le librerie necessarie e facciamo il set della cartella di lavoro

library(terra)
library(raster)
library(sf)
library(RStoolbox)
library(viridis)

setwd("C:/esame/landsat_5_1984_giugno")

# Landsat 5 bands : B1 = blue , B2 = green, B3 = visible red, B4 = NIR (0.76-0.90), B5 = SWIR (1.55-1.75)

B1 <- "LT05_L2SP_188033_19840620_20200918_02_T1_SR_B1.TIF"
B2 <- "LT05_L2SP_188033_19840620_20200918_02_T1_SR_B2.TIF"
B3 <- "LT05_L2SP_188033_19840620_20200918_02_T1_SR_B3.TIF"
B4 <- "LT05_L2SP_188033_19840620_20200918_02_T1_SR_B4.TIF"
B5 <- "LT05_L2SP_188033_19840620_20200918_02_T1_SR_B5.TIF"

# creo l'immagine satellitare

stack_NIR <- c( B4, B3, B2)
stack_SWIR <- c( B5, B3, B2)
stack_RGB <- c( B3, B2, B1)
stack_FLUO <- c( B2, B4, B3)

immagine_NIR <- rast (stack_NIR)
immagine_SWIR <- rast (stack_SWIR)
immagine_RGB <- rast (stack_RGB)
immagine_FLUO <- rast (stack_FLUO)

par (mfrow = c (1,4))

plotRGB(immagine_NIR, stretch = "lin")
plotRGB(immagine_SWIR, stretch = "lin")
plotRGB(immagine_FLUO, stretch = "lin")
plotRGB(immagine_RGB, stretch = "lin")

dev.off()

#carico lo shape file del PN della Sila

shape_sila <- st_read("shape_sila.shp")

# realizzo un crop delle immagini secondo le dimensioni del bounding box del parco

crop_NIR <- crop (immagine_NIR, shape_sila[1])
crop_SWIR <- crop (immagine_SWIR, shape_sila[1])
crop_RGB <- crop (immagine_RGB, shape_sila[1])
crop_FLUO <- crop(immagine_FLUO, shape_sila[1])

# grazie alla funzione mask ritaglio le immagini secondo il perimetro del parco

mask_NIR <- mask (crop_NIR, shape_sila[1])
mask_SWIR <- mask (crop_SWIR, shape_sila[1])
mask_FLUO <- mask (crop_FLUO, shape_sila[1])
mask_RGB <- mask (crop_RGB, shape_sila[1])

par (mfrow = c (1, 4))

plotRGB (mask_NIR, stretch = "lin")
plotRGB (mask_SWIR, stretch = "lin")
plotRGB (mask_FLUO, stretch = "lin")
plotRGB (mask_RGB, stretch  = "lin")

dev.off()

# utilizzo la funzione rescale per trasformare rendere le mie immagini ad 8 bit

scala_NIR  <- rescaleImage ( mask_NIR, ymin = 0, ymax = 255)
scala_SWIR <- rescaleImage( mask_SWIR, ymin = 0, ymax = 255)
scala_FLUO <- rescaleImage ( mask_FLUO, ymin = 0, ymax = 255)
scala_RGB <- rescaleImage ( mask_RGB, ymin = 0, ymax = 255)

# ulteriore plottaggio per visualizzare le immagini ad 8 bit

par (mfrow = c (1, 4))

plotRGB (scala_NIR, stretch = "lin")
plotRGB (scala_SWIR, stretch = "lin")
plotRGB (scala_FLUO, stretch = "lin")
plotRGB (scala_RGB, stretch  = "lin")

# stretch lineare personalizzato sulle singole immagini grazie alla funzione stretch

lin_RGB <- stretch (scala_RGB, minq = .01, maxq = .99)
lin_NIR <- stretch (scala_NIR, minq = .02, maxq = .98)
lin_SWIR <- stretch (scala_SWIR, minq = .02, maxq = .98)
lin_FLUO <- stretch (scala_FLUO, minq = .02, maxq = .98)

png(filename = "lin_plot.png", width = 1920, height = 1080)

par (mfrow = c(1,4))

plotRGB (lin_NIR, main = "NIR")
plotRGB (lin_SWIR, main = "SWIR")
plotRGB (lin_FLUO, main = "FLUO")
plotRGB (lin_RGB, main = "RGB")

dev.off()

# salvataggio delle singole immagini nella wd grazie alla funzione writeRaster, NAflag per ottenere uno sfondo bianco

writeRaster (lin_NIR, filename = "lin_NIR.png", NAflag = 255)
writeRaster (lin_SWIR, filename = "lin_SWIR.png", NAflag = 255)
writeRaster (lin_FLUO, filename = "lin_FLUO.png", NAflag = 255)
writeRaster (lin_RGB, filename = "lin_RGB.png", NAflag = 255)

# creo un raster con tutte e 5 le bande a disposizione, eseguo le funzioni crop e mask ed infine porto l'immagine ad 8 bit

multibanda <- c(B1, B2, B3, B4, B5) 
img_multibanda <- rast(multibanda)
crop_multi <- crop (img_multibanda, shape_sila[1])
mask_multi <- mask (crop_multi, shape_sila[1])
multi_scala <- rescaleImage (mask_multi, ymin = 0, ymax = 255)

plotRGB(multi_scala, 3, 2, 1, stretch = "lin")
dev.off()

writeRaster (multi_scala, filename = "multi_scala.tif", NAflag = 255)

# calcolo degli indici spettrali tramite la funzione spectralIndices 
# utlizzo della libreria viridis per la colorRampPalette

indici <- spectralIndices(multi_scala, blue = 1, green = 2, red = 3, nir= 4, swir2 = 5, indices = c("NDVI", "SAVI", "MNDWI", "GNDVI"))
plot(indici, col = cividis(100))

# per il calcolo dell'indice EVI Ã¨ necessario portare il range di colori dell'immagine da [0,255] a [0,1]

multi_scala_2 <- rescaleImage (mask_multi, ymin = 0, ymax = 1) 
EVI <- spectralIndices(multi_scala_2, blue = 1, green = 2, red = 3, nir= 4, swir2 = 5, indices = "EVI")
plot(EVI, col = turbo(100))
dev.off()

# cl <- colorRampPalette(c("darkblue", "yellow", "red", "black")) (100) colorRampPalette molto bella
# NIR e fluo di rivelano gli unici adatti ad una unSuperclass a 6 classi

# realizzo una mappa dell'uso del suolo grazie alla funzione unsuperclass

land_cover_NIR <- unsuperClass(scala_NIR, nClasses = 6)
land_cover_FLUO <- unsuperClass(scala_FLUO, nClasses = 6)

par(mfrow = c(1, 2))
plot(land_cover_NIR$map)
plot(land_cover_FLUO$map)
dev.off()

colors <- c("red", "green", "blue", "yellow", "purple", "cyan")

par(mfrow = c(1, 2))
plot(land_cover_FLUO$map, col = colors, main = "Land Cover Classification")
plot(land_cover_NIR$map, col = colors, main = "Land Cover Classification")





















