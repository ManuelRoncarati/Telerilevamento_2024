# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand")
check_and_install(required_packages)

# Imposta la working directory
setwd("D:/composite")

# Carica il raster multibanda
img_84 <- rast("L5 Composite 1984-1990_masked.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica l'erosione a ciascuna componente utilizzando un kernel di tipo disco
kernel <- shapeKernel(c(3, 3), type = "disc")
eroded_matrix1 <- erode(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), kernel)
eroded_matrix2 <- erode(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), kernel)
eroded_matrix3 <- erode(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), kernel)

# Converti le componenti erose in SpatRaster
eroded_rast1 <- rast(eroded_matrix1)
eroded_rast2 <- rast(eroded_matrix2)
eroded_rast3 <- rast(eroded_matrix3)

# Imposta l'estensione e la risoluzione delle immagini erose
ext(eroded_rast1) <- ext(stack_1984)
ext(eroded_rast2) <- ext(stack_1984)
ext(eroded_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti erose
eroded_rgb_image <- c(eroded_rast1, eroded_rast2, eroded_rast3)

# Visualizza l'immagine RGB erosa
plotRGB(eroded_rgb_image, stretch = "hist", main = "Eroded PCA RGB Image (First 3 Components)")






















# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica la smoothatura gaussiana a ciascuna componente utilizzando gaussianSmooth
gaussian_sigma <- 1.5
smoothed_matrix1 <- gaussianSmooth(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix2 <- gaussianSmooth(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix3 <- gaussianSmooth(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)

# Converti le componenti smussate in SpatRaster
smoothed_rast1 <- rast(smoothed_matrix1)
smoothed_rast2 <- rast(smoothed_matrix2)
smoothed_rast3 <- rast(smoothed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini smussate
ext(smoothed_rast1) <- ext(stack_1984)
ext(smoothed_rast2) <- ext(stack_1984)
ext(smoothed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti smussate
smoothed_rgb_image <- c(smoothed_rast1, smoothed_rast2, smoothed_rast3)

# Visualizza l'immagine RGB smussata
plotRGB(smoothed_rgb_image, stretch = "hist", main = "Smoothed PCA RGB Image (First 3 Components)")

# Applica l'erosione a ciascuna componente
eroded_matrix1 <- erode(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix2 <- erode(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix3 <- erode(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"))

# Converti le componenti erose in SpatRaster
eroded_rast1 <- rast(eroded_matrix1)
eroded_rast2 <- rast(eroded_matrix2)
eroded_rast3 <- rast(eroded_matrix3)

# Imposta l'estensione e la risoluzione delle immagini erose
ext(eroded_rast1) <- ext(stack_1984)
ext(eroded_rast2) <- ext(stack_1984)
ext(eroded_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti erose
eroded_rgb_image <- c(eroded_rast1, eroded_rast2, eroded_rast3)

# Visualizza l'immagine RGB erosa
plotRGB(eroded_rgb_image, stretch = "hist", main = "Eroded PCA RGB Image (First 3 Components)")

# Applica la dilatazione a ciascuna componente
dilated_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')

# Converti le componenti dilatate in SpatRaster
dilated_rast1 <- rast(dilated_matrix1)
dilated_rast2 <- rast(dilated_matrix2)
dilated_rast3 <- rast(dilated_matrix3)

# Imposta l'estensione e la risoluzione delle immagini dilatate
ext(dilated_rast1) <- ext(stack_1984)
ext(dilated_rast2) <- ext(stack_1984)
ext(dilated_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti dilatate
dilated_rgb_image <- c(dilated_rast1, dilated_rast2, dilated_rast3)

# Visualizza l'immagine RGB dilatata
plotRGB(dilated_rgb_image, stretch = "hist", main = "Dilated PCA RGB Image (First 3 Components)")

# Applica l'apertura morfologica a ciascuna componente
opened_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')

# Converti le componenti aperte in SpatRaster
opened_rast1 <- rast(opened_matrix1)
opened_rast2 <- rast(opened_matrix2)
opened_rast3 <- rast(opened_matrix3)

# Imposta l'estensione e la risoluzione delle immagini aperte
ext(opened_rast1) <- ext(stack_1984)
ext(opened_rast2) <- ext(stack_1984)
ext(opened_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti aperte
opened_rgb_image <- c(opened_rast1, opened_rast2, opened_rast3)

# Visualizza l'immagine RGB aperta
plotRGB(opened_rgb_image, stretch = "hist", main = "Opened PCA RGB Image (First 3 Components)")

# Applica la chiusura morfologica a ciascuna componente
closed_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')

# Converti le componenti chiuse in SpatRaster
closed_rast1 <- rast(closed_matrix1)
closed_rast2 <- rast(closed_matrix2)
closed_rast3 <- rast(closed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini chiuse
ext(closed_rast1) <- ext(stack_1984)
ext(closed_rast2) <- ext(stack_1984)
ext(closed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti chiuse
closed_rgb_image <- c(closed_rast1, closed_rast2, closed_rast3)

# Visualizza l'immagine RGB chiusa
plotRGB(closed_rgb_image, stretch = "hist", main = "Closed PCA RGB Image (First 3 Components)")






















# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica la smoothatura gaussiana a ciascuna componente utilizzando gaussianSmooth
gaussian_sigma <- 1.5
smoothed_matrix1 <- gaussianSmooth(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix2 <- gaussianSmooth(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix3 <- gaussianSmooth(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)

# Converti le componenti smussate in SpatRaster
smoothed_rast1 <- rast(smoothed_matrix1)
smoothed_rast2 <- rast(smoothed_matrix2)
smoothed_rast3 <- rast(smoothed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini smussate
ext(smoothed_rast1) <- ext(stack_1984)
ext(smoothed_rast2) <- ext(stack_1984)
ext(smoothed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti smussate
smoothed_rgb_image <- c(smoothed_rast1, smoothed_rast2, smoothed_rast3)

# Visualizza l'immagine RGB smussata
plotRGB(smoothed_rgb_image, stretch = "hist", main = "Smoothed PCA RGB Image (First 3 Components)")

# Applica l'erosione a ciascuna componente
eroded_matrix1 <- erode(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix2 <- erode(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix3 <- erode(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"))

# Converti le componenti erose in SpatRaster
eroded_rast1 <- rast(eroded_matrix1)
eroded_rast2 <- rast(eroded_matrix2)
eroded_rast3 <- rast(eroded_matrix3)

# Imposta l'estensione e la risoluzione delle immagini erose
ext(eroded_rast1) <- ext(stack_1984)
ext(eroded_rast2) <- ext(stack_1984)
ext(eroded_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti erose
eroded_rgb_image <- c(eroded_rast1, eroded_rast2, eroded_rast3)

# Visualizza l'immagine RGB erosa
plotRGB(eroded_rgb_image, stretch = "hist", main = "Eroded PCA RGB Image (First 3 Components)")

# Applica la dilatazione a ciascuna componente
dilated_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')

# Converti le componenti dilatate in SpatRaster
dilated_rast1 <- rast(dilated_matrix1)
dilated_rast2 <- rast(dilated_matrix2)
dilated_rast3 <- rast(dilated_matrix3)

# Imposta l'estensione e la risoluzione delle immagini dilatate
ext(dilated_rast1) <- ext(stack_1984)
ext(dilated_rast2) <- ext(stack_1984)
ext(dilated_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti dilatate
dilated_rgb_image <- c(dilated_rast1, dilated_rast2, dilated_rast3)

# Visualizza l'immagine RGB dilatata
plotRGB(dilated_rgb_image, stretch = "hist", main = "Dilated PCA RGB Image (First 3 Components)")

# Applica l'apertura morfologica a ciascuna componente
opened_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')

# Converti le componenti aperte in SpatRaster
opened_rast1 <- rast(opened_matrix1)
opened_rast2 <- rast(opened_matrix2)
opened_rast3 <- rast(opened_matrix3)

# Imposta l'estensione e la risoluzione delle immagini aperte
ext(opened_rast1) <- ext(stack_1984)
ext(opened_rast2) <- ext(stack_1984)
ext(opened_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti aperte
opened_rgb_image <- c(opened_rast1, opened_rast2, opened_rast3)

# Visualizza l'immagine RGB aperta
plotRGB(opened_rgb_image, stretch = "hist", main = "Opened PCA RGB Image (First 3 Components)")

# Applica la chiusura morfologica a ciascuna componente
closed_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')

# Converti le componenti chiuse in SpatRaster
closed_rast1 <- rast(closed_matrix1)
closed_rast2 <- rast(closed_matrix2)
closed_rast3 <- rast(closed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini chiuse
ext(closed_rast1) <- ext(stack_1984)
ext(closed_rast2) <- ext(stack_1984)
ext(closed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti chiuse
closed_rgb_image <- c(closed_rast1, closed_rast2, closed_rast3)

# Visualizza l'immagine RGB chiusa
plotRGB(closed_rgb_image, stretch = "hist", main = "Closed PCA RGB Image (First 3 Components)")

# Applica il filtro mediano a ciascuna componente
median_matrix1 <- medianFilter(smoothed_matrix1, 3)
median_matrix2 <- medianFilter(smoothed_matrix2, 3)
median_matrix3 <- medianFilter(smoothed_matrix3, 3)

# Converti le componenti filtrate mediane in SpatRaster
median_rast1 <- rast(median_matrix1)
median_rast2 <- rast(median_matrix2)
median_rast3 <- rast(median_matrix3)

# Imposta l'estensione e la risoluzione delle immagini filtrate mediane
ext(median_rast1) <- ext(stack_1984)
ext(median_rast2) <- ext(stack_1984)
ext(median_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti filtrate mediane
median_rgb_image <- c(median_rast1, median_rast2, median_rast3)

# Visualizza l'immagine RGB filtrata mediana
plotRGB(median_rgb_image, stretch = "hist", main = "Median Filtered PCA RGB Image (First 3 Components)")

# Applica il filtro di Sobel a ciascuna componente
sobel_matrix1 <- sobelFilter(smoothed_matrix1)
sobel_matrix2 <- sobelFilter(smoothed_matrix2)
sobel_matrix3 <- sobelFilter(smoothed_matrix3)

# Converti le componenti con filtro Sobel in SpatRaster
sobel_rast1 <- rast(sobel_matrix1)
sobel_rast2 <- rast(sobel_matrix2)
sobel_rast3 <- rast(sobel_matrix3)

# Imposta l'estensione e la risoluzione delle immagini con filtro Sobel
ext(sobel_rast1) <- ext(stack_1984)
ext(sobel_rast2) <- ext(stack_1984)
ext(sobel_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti con filtro Sobel
sobel_rgb_image <- c(sobel_rast1, sobel_rast2, sobel_rast3)

# Visualizza l'immagine RGB con filtro Sobel
plotRGB(sobel_rgb_image, stretch = "hist", main = "Sobel Filtered PCA RGB Image (First 3 Components)")






#SNIC

# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand", "OpenImageR")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Normalizza i valori PCA per portarli tra 0 e 255
normalize_to_255 <- function(x) {
    x_min <- min(x, na.rm = TRUE)
    x_max <- max(x, na.rm = TRUE)
    ((x - x_min) / (x_max - x_min)) * 255
}

full_pca1 <- normalize_to_255(full_pca1)
full_pca2 <- normalize_to_255(full_pca2)
full_pca3 <- normalize_to_255(full_pca3)

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica l'algoritmo di superpixel utilizzando OpenImageR
library(OpenImageR)
pca_rgb_array <- as.array(rgb_image)
superpixel_result <- superpixels(input_image = pca_rgb_array, method = "slic", superpixel = 2000, compactness = 20, return_labels = TRUE)

# Calcola la media dei valori RGB per ciascun superpixel
superpixel_labels <- superpixel_result$labels
unique_labels <- unique(as.vector(superpixel_labels))
mean_rgb_values <- sapply(unique_labels, function(label) {
    mask <- (superpixel_labels == label)
    r_mean <- mean(pca_rgb_array[,,1][mask], na.rm = TRUE)
    g_mean <- mean(pca_rgb_array[,,2][mask], na.rm = TRUE)
    b_mean <- mean(pca_rgb_array[,,3][mask], na.rm = TRUE)
    return(c(r_mean, g_mean, b_mean))
})

# Rimuovi eventuali valori NA dalle medie
mean_rgb_values[is.na(mean_rgb_values)] <- 0

# Crea un'immagine con i superpixel colorati in base alla media RGB
superpixel_colored <- array(0, dim = dim(pca_rgb_array))
for (i in seq_along(unique_labels)) {
    label <- unique_labels[i]
    mask <- (superpixel_labels == label)
    superpixel_colored[,,1][mask] <- mean_rgb_values[1, i]
    superpixel_colored[,,2][mask] <- mean_rgb_values[2, i]
    superpixel_colored[,,3][mask] <- mean_rgb_values[3, i]
}

# Normalizza l'immagine per garantire che i valori siano tra 0 e 1
superpixel_colored <- pmax(pmin(superpixel_colored, 255), 0) / 255

# Visualizza l'immagine segmentata in superpixel colorati
plot(as.raster(superpixel_colored), main = "Superpixel Segmentation (Colored by Mean RGB)")














# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand", "OpenImageR", "EBImage")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Normalizza i valori PCA per portarli tra 0 e 255
normalize_to_255 <- function(x) {
    x_min <- min(x, na.rm = TRUE)
    x_max <- max(x, na.rm = TRUE)
    ((x - x_min) / (x_max - x_min)) * 255
}

full_pca1 <- normalize_to_255(full_pca1)
full_pca2 <- normalize_to_255(full_pca2)
full_pca3 <- normalize_to_255(full_pca3)

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica l'algoritmo di superpixel utilizzando OpenImageR con un maggiore focus sulla compattezza
library(OpenImageR)
pca_rgb_array <- as.array(rgb_image)
superpixel_result <- superpixels(input_image = pca_rgb_array, method = "slic", superpixel = 100, compactness = 50, return_labels = TRUE)

# Calcola la media dei valori RGB per ciascun superpixel
superpixel_labels <- superpixel_result$labels
unique_labels <- unique(as.vector(superpixel_labels))
mean_rgb_values <- sapply(unique_labels, function(label) {
  mask <- (superpixel_labels == label)
  r_mean <- mean(pca_rgb_array[,,1][mask], na.rm = TRUE)
  g_mean <- mean(pca_rgb_array[,,2][mask], na.rm = TRUE)
  b_mean <- mean(pca_rgb_array[,,3][mask], na.rm = TRUE)
  return(c(r_mean, g_mean, b_mean))
})

# Rimuovi eventuali valori NA dalle medie
mean_rgb_values[is.na(mean_rgb_values)] <- 0

# Crea un'immagine con i superpixel colorati in base alla media RGB
superpixel_colored <- array(0, dim = dim(pca_rgb_array))
for (i in seq_along(unique_labels)) {
  label <- unique_labels[i]
  mask <- (superpixel_labels == label)
  superpixel_colored[,,1][mask] <- mean_rgb_values[1, i]
  superpixel_colored[,,2][mask] <- mean_rgb_values[2, i]
  superpixel_colored[,,3][mask] <- mean_rgb_values[3, i]
}

# Normalizza l'immagine per garantire che i valori siano tra 0 e 1
superpixel_colored <- pmax(pmin(superpixel_colored, 255), 0) / 255

# Visualizza l'immagine segmentata in superpixel colorati
plot(as.raster(superpixel_colored), main = "Superpixel Segmentation (Colored by Mean RGB)")

# Applicazione di una dilatazione morfologica per unire piccoli segmenti
library(EBImage)
for (i in 1:3) {
  superpixel_colored[,,i] <- dilate(superpixel_colored[,,i], makeBrush(5, shape = 'disc'))
}

# Visualizza l'immagine segmentata dopo la dilatazione
plot(as.raster(superpixel_colored), main = "Segmentazione con Dilatazione (Colored by Mean RGB)")
