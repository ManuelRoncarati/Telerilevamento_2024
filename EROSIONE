# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand")
check_and_install(required_packages)

# Imposta la working directory
setwd("D:/composite")

# Carica il raster multibanda
img_84 <- rast("L5 Composite 1984-1990_masked.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica l'erosione a ciascuna componente utilizzando un kernel di tipo disco
kernel <- shapeKernel(c(3, 3), type = "disc")
eroded_matrix1 <- erode(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), kernel)
eroded_matrix2 <- erode(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), kernel)
eroded_matrix3 <- erode(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), kernel)

# Converti le componenti erose in SpatRaster
eroded_rast1 <- rast(eroded_matrix1)
eroded_rast2 <- rast(eroded_matrix2)
eroded_rast3 <- rast(eroded_matrix3)

# Imposta l'estensione e la risoluzione delle immagini erose
ext(eroded_rast1) <- ext(stack_1984)
ext(eroded_rast2) <- ext(stack_1984)
ext(eroded_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti erose
eroded_rgb_image <- c(eroded_rast1, eroded_rast2, eroded_rast3)

# Visualizza l'immagine RGB erosa
plotRGB(eroded_rgb_image, stretch = "hist", main = "Eroded PCA RGB Image (First 3 Components)")






















# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica la smoothatura gaussiana a ciascuna componente utilizzando gaussianSmooth
gaussian_sigma <- 1.5
smoothed_matrix1 <- gaussianSmooth(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix2 <- gaussianSmooth(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix3 <- gaussianSmooth(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)

# Converti le componenti smussate in SpatRaster
smoothed_rast1 <- rast(smoothed_matrix1)
smoothed_rast2 <- rast(smoothed_matrix2)
smoothed_rast3 <- rast(smoothed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini smussate
ext(smoothed_rast1) <- ext(stack_1984)
ext(smoothed_rast2) <- ext(stack_1984)
ext(smoothed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti smussate
smoothed_rgb_image <- c(smoothed_rast1, smoothed_rast2, smoothed_rast3)

# Visualizza l'immagine RGB smussata
plotRGB(smoothed_rgb_image, stretch = "hist", main = "Smoothed PCA RGB Image (First 3 Components)")

# Applica l'erosione a ciascuna componente
eroded_matrix1 <- erode(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix2 <- erode(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix3 <- erode(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"))

# Converti le componenti erose in SpatRaster
eroded_rast1 <- rast(eroded_matrix1)
eroded_rast2 <- rast(eroded_matrix2)
eroded_rast3 <- rast(eroded_matrix3)

# Imposta l'estensione e la risoluzione delle immagini erose
ext(eroded_rast1) <- ext(stack_1984)
ext(eroded_rast2) <- ext(stack_1984)
ext(eroded_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti erose
eroded_rgb_image <- c(eroded_rast1, eroded_rast2, eroded_rast3)

# Visualizza l'immagine RGB erosa
plotRGB(eroded_rgb_image, stretch = "hist", main = "Eroded PCA RGB Image (First 3 Components)")

# Applica la dilatazione a ciascuna componente
dilated_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')

# Converti le componenti dilatate in SpatRaster
dilated_rast1 <- rast(dilated_matrix1)
dilated_rast2 <- rast(dilated_matrix2)
dilated_rast3 <- rast(dilated_matrix3)

# Imposta l'estensione e la risoluzione delle immagini dilatate
ext(dilated_rast1) <- ext(stack_1984)
ext(dilated_rast2) <- ext(stack_1984)
ext(dilated_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti dilatate
dilated_rgb_image <- c(dilated_rast1, dilated_rast2, dilated_rast3)

# Visualizza l'immagine RGB dilatata
plotRGB(dilated_rgb_image, stretch = "hist", main = "Dilated PCA RGB Image (First 3 Components)")

# Applica l'apertura morfologica a ciascuna componente
opened_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')

# Converti le componenti aperte in SpatRaster
opened_rast1 <- rast(opened_matrix1)
opened_rast2 <- rast(opened_matrix2)
opened_rast3 <- rast(opened_matrix3)

# Imposta l'estensione e la risoluzione delle immagini aperte
ext(opened_rast1) <- ext(stack_1984)
ext(opened_rast2) <- ext(stack_1984)
ext(opened_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti aperte
opened_rgb_image <- c(opened_rast1, opened_rast2, opened_rast3)

# Visualizza l'immagine RGB aperta
plotRGB(opened_rgb_image, stretch = "hist", main = "Opened PCA RGB Image (First 3 Components)")

# Applica la chiusura morfologica a ciascuna componente
closed_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')

# Converti le componenti chiuse in SpatRaster
closed_rast1 <- rast(closed_matrix1)
closed_rast2 <- rast(closed_matrix2)
closed_rast3 <- rast(closed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini chiuse
ext(closed_rast1) <- ext(stack_1984)
ext(closed_rast2) <- ext(stack_1984)
ext(closed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti chiuse
closed_rgb_image <- c(closed_rast1, closed_rast2, closed_rast3)

# Visualizza l'immagine RGB chiusa
plotRGB(closed_rgb_image, stretch = "hist", main = "Closed PCA RGB Image (First 3 Components)")






















# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica la smoothatura gaussiana a ciascuna componente utilizzando gaussianSmooth
gaussian_sigma <- 1.5
smoothed_matrix1 <- gaussianSmooth(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix2 <- gaussianSmooth(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)
smoothed_matrix3 <- gaussianSmooth(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE), gaussian_sigma)

# Converti le componenti smussate in SpatRaster
smoothed_rast1 <- rast(smoothed_matrix1)
smoothed_rast2 <- rast(smoothed_matrix2)
smoothed_rast3 <- rast(smoothed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini smussate
ext(smoothed_rast1) <- ext(stack_1984)
ext(smoothed_rast2) <- ext(stack_1984)
ext(smoothed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti smussate
smoothed_rgb_image <- c(smoothed_rast1, smoothed_rast2, smoothed_rast3)

# Visualizza l'immagine RGB smussata
plotRGB(smoothed_rgb_image, stretch = "hist", main = "Smoothed PCA RGB Image (First 3 Components)")

# Applica l'erosione a ciascuna componente
eroded_matrix1 <- erode(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix2 <- erode(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"))
eroded_matrix3 <- erode(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"))

# Converti le componenti erose in SpatRaster
eroded_rast1 <- rast(eroded_matrix1)
eroded_rast2 <- rast(eroded_matrix2)
eroded_rast3 <- rast(eroded_matrix3)

# Imposta l'estensione e la risoluzione delle immagini erose
ext(eroded_rast1) <- ext(stack_1984)
ext(eroded_rast2) <- ext(stack_1984)
ext(eroded_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti erose
eroded_rgb_image <- c(eroded_rast1, eroded_rast2, eroded_rast3)

# Visualizza l'immagine RGB erosa
plotRGB(eroded_rgb_image, stretch = "hist", main = "Eroded PCA RGB Image (First 3 Components)")

# Applica la dilatazione a ciascuna componente
dilated_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')
dilated_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'dilation')

# Converti le componenti dilatate in SpatRaster
dilated_rast1 <- rast(dilated_matrix1)
dilated_rast2 <- rast(dilated_matrix2)
dilated_rast3 <- rast(dilated_matrix3)

# Imposta l'estensione e la risoluzione delle immagini dilatate
ext(dilated_rast1) <- ext(stack_1984)
ext(dilated_rast2) <- ext(stack_1984)
ext(dilated_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti dilatate
dilated_rgb_image <- c(dilated_rast1, dilated_rast2, dilated_rast3)

# Visualizza l'immagine RGB dilatata
plotRGB(dilated_rgb_image, stretch = "hist", main = "Dilated PCA RGB Image (First 3 Components)")

# Applica l'apertura morfologica a ciascuna componente
opened_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')
opened_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'opening')

# Converti le componenti aperte in SpatRaster
opened_rast1 <- rast(opened_matrix1)
opened_rast2 <- rast(opened_matrix2)
opened_rast3 <- rast(opened_matrix3)

# Imposta l'estensione e la risoluzione delle immagini aperte
ext(opened_rast1) <- ext(stack_1984)
ext(opened_rast2) <- ext(stack_1984)
ext(opened_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti aperte
opened_rgb_image <- c(opened_rast1, opened_rast2, opened_rast3)

# Visualizza l'immagine RGB aperta
plotRGB(opened_rgb_image, stretch = "hist", main = "Opened PCA RGB Image (First 3 Components)")

# Applica la chiusura morfologica a ciascuna componente
closed_matrix1 <- morph(smoothed_matrix1, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix2 <- morph(smoothed_matrix2, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')
closed_matrix3 <- morph(smoothed_matrix3, shapeKernel(c(3, 3), type = "disc"), operation = 'closing')

# Converti le componenti chiuse in SpatRaster
closed_rast1 <- rast(closed_matrix1)
closed_rast2 <- rast(closed_matrix2)
closed_rast3 <- rast(closed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini chiuse
ext(closed_rast1) <- ext(stack_1984)
ext(closed_rast2) <- ext(stack_1984)
ext(closed_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti chiuse
closed_rgb_image <- c(closed_rast1, closed_rast2, closed_rast3)

# Visualizza l'immagine RGB chiusa
plotRGB(closed_rgb_image, stretch = "hist", main = "Closed PCA RGB Image (First 3 Components)")

# Applica il filtro mediano a ciascuna componente
median_matrix1 <- medianFilter(smoothed_matrix1, 3)
median_matrix2 <- medianFilter(smoothed_matrix2, 3)
median_matrix3 <- medianFilter(smoothed_matrix3, 3)

# Converti le componenti filtrate mediane in SpatRaster
median_rast1 <- rast(median_matrix1)
median_rast2 <- rast(median_matrix2)
median_rast3 <- rast(median_matrix3)

# Imposta l'estensione e la risoluzione delle immagini filtrate mediane
ext(median_rast1) <- ext(stack_1984)
ext(median_rast2) <- ext(stack_1984)
ext(median_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti filtrate mediane
median_rgb_image <- c(median_rast1, median_rast2, median_rast3)

# Visualizza l'immagine RGB filtrata mediana
plotRGB(median_rgb_image, stretch = "hist", main = "Median Filtered PCA RGB Image (First 3 Components)")

# Applica il filtro di Sobel a ciascuna componente
sobel_matrix1 <- sobelFilter(smoothed_matrix1)
sobel_matrix2 <- sobelFilter(smoothed_matrix2)
sobel_matrix3 <- sobelFilter(smoothed_matrix3)

# Converti le componenti con filtro Sobel in SpatRaster
sobel_rast1 <- rast(sobel_matrix1)
sobel_rast2 <- rast(sobel_matrix2)
sobel_rast3 <- rast(sobel_matrix3)

# Imposta l'estensione e la risoluzione delle immagini con filtro Sobel
ext(sobel_rast1) <- ext(stack_1984)
ext(sobel_rast2) <- ext(stack_1984)
ext(sobel_rast3) <- ext(stack_1984)

# Crea l'immagine RGB delle componenti con filtro Sobel
sobel_rgb_image <- c(sobel_rast1, sobel_rast2, sobel_rast3)

# Visualizza l'immagine RGB con filtro Sobel
plotRGB(sobel_rgb_image, stretch = "hist", main = "Sobel Filtered PCA RGB Image (First 3 Components)")






#SNIC

# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand", "OpenImageR")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Normalizza i valori PCA per portarli tra 0 e 255
normalize_to_255 <- function(x) {
    x_min <- min(x, na.rm = TRUE)
    x_max <- max(x, na.rm = TRUE)
    ((x - x_min) / (x_max - x_min)) * 255
}

full_pca1 <- normalize_to_255(full_pca1)
full_pca2 <- normalize_to_255(full_pca2)
full_pca3 <- normalize_to_255(full_pca3)

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica l'algoritmo di superpixel utilizzando OpenImageR
library(OpenImageR)
pca_rgb_array <- as.array(rgb_image)
superpixel_result <- superpixels(input_image = pca_rgb_array, method = "slic", superpixel = 2000, compactness = 20, return_labels = TRUE)

# Calcola la media dei valori RGB per ciascun superpixel
superpixel_labels <- superpixel_result$labels
unique_labels <- unique(as.vector(superpixel_labels))
mean_rgb_values <- sapply(unique_labels, function(label) {
    mask <- (superpixel_labels == label)
    r_mean <- mean(pca_rgb_array[,,1][mask], na.rm = TRUE)
    g_mean <- mean(pca_rgb_array[,,2][mask], na.rm = TRUE)
    b_mean <- mean(pca_rgb_array[,,3][mask], na.rm = TRUE)
    return(c(r_mean, g_mean, b_mean))
})

# Rimuovi eventuali valori NA dalle medie
mean_rgb_values[is.na(mean_rgb_values)] <- 0

# Crea un'immagine con i superpixel colorati in base alla media RGB
superpixel_colored <- array(0, dim = dim(pca_rgb_array))
for (i in seq_along(unique_labels)) {
    label <- unique_labels[i]
    mask <- (superpixel_labels == label)
    superpixel_colored[,,1][mask] <- mean_rgb_values[1, i]
    superpixel_colored[,,2][mask] <- mean_rgb_values[2, i]
    superpixel_colored[,,3][mask] <- mean_rgb_values[3, i]
}

# Normalizza l'immagine per garantire che i valori siano tra 0 e 1
superpixel_colored <- pmax(pmin(superpixel_colored, 255), 0) / 255

# Visualizza l'immagine segmentata in superpixel colorati
plot(as.raster(superpixel_colored), main = "Superpixel Segmentation (Colored by Mean RGB)")














# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand", "OpenImageR", "EBImage")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Normalizza i valori PCA per portarli tra 0 e 255
normalize_to_255 <- function(x) {
    x_min <- min(x, na.rm = TRUE)
    x_max <- max(x, na.rm = TRUE)
    ((x - x_min) / (x_max - x_min)) * 255
}

full_pca1 <- normalize_to_255(full_pca1)
full_pca2 <- normalize_to_255(full_pca2)
full_pca3 <- normalize_to_255(full_pca3)

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica l'algoritmo di superpixel utilizzando OpenImageR con un maggiore focus sulla compattezza
library(OpenImageR)
pca_rgb_array <- as.array(rgb_image)
superpixel_result <- superpixels(input_image = pca_rgb_array, method = "slic", superpixel = 100, compactness = 50, return_labels = TRUE)

# Calcola la media dei valori RGB per ciascun superpixel
superpixel_labels <- superpixel_result$labels
unique_labels <- unique(as.vector(superpixel_labels))
mean_rgb_values <- sapply(unique_labels, function(label) {
  mask <- (superpixel_labels == label)
  r_mean <- mean(pca_rgb_array[,,1][mask], na.rm = TRUE)
  g_mean <- mean(pca_rgb_array[,,2][mask], na.rm = TRUE)
  b_mean <- mean(pca_rgb_array[,,3][mask], na.rm = TRUE)
  return(c(r_mean, g_mean, b_mean))
})

# Rimuovi eventuali valori NA dalle medie
mean_rgb_values[is.na(mean_rgb_values)] <- 0

# Crea un'immagine con i superpixel colorati in base alla media RGB
superpixel_colored <- array(0, dim = dim(pca_rgb_array))
for (i in seq_along(unique_labels)) {
  label <- unique_labels[i]
  mask <- (superpixel_labels == label)
  superpixel_colored[,,1][mask] <- mean_rgb_values[1, i]
  superpixel_colored[,,2][mask] <- mean_rgb_values[2, i]
  superpixel_colored[,,3][mask] <- mean_rgb_values[3, i]
}

# Normalizza l'immagine per garantire che i valori siano tra 0 e 1
superpixel_colored <- pmax(pmin(superpixel_colored, 255), 0) / 255

# Visualizza l'immagine segmentata in superpixel colorati
plot(as.raster(superpixel_colored), main = "Superpixel Segmentation (Colored by Mean RGB)")

# Applicazione di una dilatazione morfologica per unire piccoli segmenti
library(EBImage)
for (i in 1:3) {
  superpixel_colored[,,i] <- dilate(superpixel_colored[,,i], makeBrush(5, shape = 'disc'))
}

# Visualizza l'immagine segmentata dopo la dilatazione
plot(as.raster(superpixel_colored), main = "Segmentazione con Dilatazione (Colored by Mean RGB)")
















# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand", "OpenImageR", "EBImage")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
cat("Numero di pixel dopo la PCA: ", length(full_pca1), "
")
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Normalizza i valori PCA per portarli tra 0 e 255
normalize_to_255 <- function(x) {
    x_min <- min(x, na.rm = TRUE)
    x_max <- max(x, na.rm = TRUE)
    ((x - x_min) / (x_max - x_min)) * 255
}

full_pca1 <- normalize_to_255(full_pca1)
full_pca2 <- normalize_to_255(full_pca2)
full_pca3 <- normalize_to_255(full_pca3)

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Visualizza l'immagine RGB senza erosione
plotRGB(rgb_image, stretch = "hist", main = "PCA RGB Image (First 3 Components, No Erosion)")

# Applica l'algoritmo di superpixel utilizzando OpenImageR con un maggiore focus sulla compattezza
library(OpenImageR)
pca_rgb_array <- as.array(rgb_image)
  # Assicurati che le dimensioni siano correttamente orientate
superpixel_result <- superpixels(input_image = pca_rgb_array, method = "slic", superpixel = 16, compactness = 0, return_labels = TRUE)

# Stampa il numero di pixel dopo SNIC
cat("Numero di pixel dopo SNIC: ", length(superpixel_result$labels), "
")

# Calcola la media dei valori RGB per ciascun superpixel
superpixel_labels <- superpixel_result$labels
unique_labels <- unique(as.vector(superpixel_labels))
mean_rgb_values <- sapply(unique_labels, function(label) {
  mask <- (superpixel_labels == label)
  r_mean <- mean(pca_rgb_array[,,1][mask], na.rm = TRUE)
  g_mean <- mean(pca_rgb_array[,,2][mask], na.rm = TRUE)
  b_mean <- mean(pca_rgb_array[,,3][mask], na.rm = TRUE)
  return(c(r_mean, g_mean, b_mean))
})

# Rimuovi eventuali valori NA dalle medie
mean_rgb_values[is.na(mean_rgb_values)] <- 0

# Crea un'immagine con i superpixel colorati in base alla media RGB
superpixel_colored <- array(0, dim = dim(pca_rgb_array))
for (i in seq_along(unique_labels)) {
  label <- unique_labels[i]
  mask <- (superpixel_labels == label)
  superpixel_colored[,,1][mask] <- mean_rgb_values[1, i]
  superpixel_colored[,,2][mask] <- mean_rgb_values[2, i]
  superpixel_colored[,,3][mask] <- mean_rgb_values[3, i]
}

# Normalizza l'immagine per garantire che i valori siano tra 0 e 1
superpixel_colored <- pmax(pmin(superpixel_colored, 255), 0) / 255

# Assicurati che l'orientamento dell'immagine sia corretto


# Visualizza l'immagine segmentata in superpixel colorati
plot(as.raster(superpixel_colored), main = "Superpixel Segmentation (Colored by Mean RGB)")

# Applicazione di una dilatazione morfologica per unire piccoli segmenti
library(EBImage)
for (i in 1:3) {
  superpixel_colored[,,i] <- dilate(superpixel_colored[,,i], makeBrush(5, shape = 'disc'))
}

# Visualizza l'immagine segmentata dopo la dilatazione
plot(as.raster(superpixel_colored), main = "Segmentazione con Dilatazione (Colored by Mean RGB)")
























# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand", "OpenImageR", "EBImage", "leaflet", "mapview")
check_and_install(required_packages)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

# Stampa il numero di pixel dopo la PCA
cat("Numero di pixel dopo la PCA: ", length(full_pca1), "
")

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Normalizza i valori PCA per portarli tra 0 e 255
normalize_to_255 <- function(x) {
    x_min <- min(x, na.rm = TRUE)
    x_max <- max(x, na.rm = TRUE)
    ((x - x_min) / (x_max - x_min)) * 255
}

full_pca1 <- normalize_to_255(full_pca1)
full_pca2 <- normalize_to_255(full_pca2)
full_pca3 <- normalize_to_255(full_pca3)

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Converti l'immagine RGB in un RasterBrick per la visualizzazione con mapview
library(raster)
rgb_image_raster <- brick(
    raster(pca_rast1),
    raster(pca_rast2),
    raster(pca_rast3)
)
crs(rgb_image_raster) <- crs(stack_1984)
# Visualizza l'immagine RGB senza erosione
rgb_map <- viewRGB(rgb_image_raster, r = 1, g = 2, b = 3, maxpixels = 142266)

leaflet_map <- rgb_map@map %>%
    addProviderTiles(providers$Esri.WorldImagery) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addProviderTiles(providers$OpenStreetMap) %>%
    addLayersControl(
        baseGroups = c("Esri.WorldImagery", "CartoDB.Positron", "OpenStreetMap"),
        options = layersControlOptions(collapsed = FALSE)
    )

leaflet_map

# Applica l'algoritmo di superpixel utilizzando OpenImageR con un maggiore focus sulla compattezza
library(OpenImageR)
pca_rgb_array <- as.array(rgb_image)
# Assicurati che le dimensioni siano correttamente orientate
superpixel_result <- superpixels(input_image = pca_rgb_array, method = "slic", superpixel = 16, compactness = 0, return_labels = TRUE)

# Stampa il numero di pixel dopo SNIC
cat("Numero di pixel dopo SNIC: ", length(superpixel_result$labels), "
")

# Calcola la media dei valori RGB per ciascun superpixel
superpixel_labels <- superpixel_result$labels
unique_labels <- unique(as.vector(superpixel_labels))
mean_rgb_values <- sapply(unique_labels, function(label) {
    mask <- (superpixel_labels == label)
    r_mean <- mean(pca_rgb_array[,,1][mask], na.rm = TRUE)
    g_mean <- mean(pca_rgb_array[,,2][mask], na.rm = TRUE)
    b_mean <- mean(pca_rgb_array[,,3][mask], na.rm = TRUE)
    return(c(r_mean, g_mean, b_mean))
})

# Rimuovi eventuali valori NA dalle medie
mean_rgb_values[is.na(mean_rgb_values)] <- 0

# Crea un'immagine con i superpixel colorati in base alla media RGB
superpixel_colored <- array(0, dim = dim(pca_rgb_array))
for (i in seq_along(unique_labels)) {
    label <- unique_labels[i]
    mask <- (superpixel_labels == label)
    superpixel_colored[,,1][mask] <- mean_rgb_values[1, i]
    superpixel_colored[,,2][mask] <- mean_rgb_values[2, i]
    superpixel_colored[,,3][mask] <- mean_rgb_values[3, i]
}

# Normalizza l'immagine per garantire che i valori siano tra 0 e 1
superpixel_colored <- pmax(pmin(superpixel_colored, 255), 0) / 255

# Assicurati che l'orientamento dell'immagine sia corretto






# Crea un RasterBrick per la visualizzazione dell'immagine segmentata con superpixel
superpixel_rast_rgb <- brick(
    raster(as.matrix(superpixel_colored[,,1])),
    raster(as.matrix(superpixel_colored[,,2])),
    raster(as.matrix(superpixel_colored[,,3]))
)
crs(superpixel_rast_rgb) <- crs(stack_1984)
extent(superpixel_rast_rgb) <- extent(rgb_image_raster)
crs(superpixel_rast_rgb) <- crs(stack_1984)


mapview_options <- mapviewOptions()
superpixel_map <- viewRGB(superpixel_rast_rgb, r = 1, g = 2, b = 3, maxpixels = 142266)

leaflet_superpixel_map <- superpixel_map@map %>%
    addProviderTiles(providers$Esri.WorldImagery) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addProviderTiles(providers$OpenStreetMap) %>%
    addLayersControl(
        baseGroups = c("Esri.WorldImagery", "CartoDB.Positron", "OpenStreetMap"),
        options = layersControlOptions(collapsed = FALSE)
    )

leaflet_superpixel_map



























# Carica le librerie necessarie
library(terra)
library(leaflet)
library(leafem)
library(raster)
library(OpenImageR)

# Imposta la working directory
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione dell'immagine per ogni componente
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Normalizza i valori PCA per portarli tra 0 e 255
normalize_to_255 <- function(x) {
    x_min <- min(x, na.rm = TRUE)
    x_max <- max(x, na.rm = TRUE)
    ((x - x_min) / (x_max - x_min)) * 255
}

full_pca1 <- normalize_to_255(full_pca1)
full_pca2 <- normalize_to_255(full_pca2)
full_pca3 <- normalize_to_255(full_pca3)

# Converti ciascuna componente in SpatRaster senza erosione
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea l'immagine RGB senza erosione
rgb_image <- c(pca_rast1, pca_rast2, pca_rast3)

# Converti l'immagine RGB in un RasterBrick per la visualizzazione con leaflet
rgb_image_raster <- brick(
    raster(pca_rast1),
    raster(pca_rast2),
    raster(pca_rast3)
)
crs(rgb_image_raster) <- crs(stack_1984)

# Applica l'algoritmo di superpixel utilizzando OpenImageR con un maggiore focus sulla compattezza
pca_rgb_array <- as.array(rgb_image)
superpixel_result <- superpixels(input_image = pca_rgb_array, method = "slic", superpixel = 16, compactness = 0, return_labels = TRUE)

# Calcola la media dei valori RGB per ciascun superpixel
superpixel_labels <- superpixel_result$labels
unique_labels <- unique(as.vector(superpixel_labels))
mean_rgb_values <- sapply(unique_labels, function(label) {
    mask <- (superpixel_labels == label)
    r_mean <- mean(pca_rgb_array[,,1][mask], na.rm = TRUE)
    g_mean <- mean(pca_rgb_array[,,2][mask], na.rm = TRUE)
    b_mean <- mean(pca_rgb_array[,,3][mask], na.rm = TRUE)
    return(c(r_mean, g_mean, b_mean))
})

# Rimuovi eventuali valori NA dalle medie
mean_rgb_values[is.na(mean_rgb_values)] <- 0

# Crea un'immagine con i superpixel colorati in base alla media RGB
superpixel_colored <- array(0, dim = dim(pca_rgb_array))
for (i in seq_along(unique_labels)) {
    label <- unique_labels[i]
    mask <- (superpixel_labels == label)
    superpixel_colored[,,1][mask] <- mean_rgb_values[1, i]
    superpixel_colored[,,2][mask] <- mean_rgb_values[2, i]
    superpixel_colored[,,3][mask] <- mean_rgb_values[3, i]
}

# Normalizza l'immagine per garantire che i valori siano tra 0 e 1
superpixel_colored <- pmax(pmin(superpixel_colored, 255), 0) / 255

# Crea un RasterBrick per la visualizzazione dell'immagine segmentata con superpixel
superpixel_rast_rgb <- brick(
    raster(as.matrix(superpixel_colored[,,1])),
    raster(as.matrix(superpixel_colored[,,2])),
    raster(as.matrix(superpixel_colored[,,3]))
)
crs(superpixel_rast_rgb) <- crs(stack_1984)
extent(superpixel_rast_rgb) <- extent(rgb_image_raster)

# Visualizza l'immagine RGB originale e quella segmentata con leaflet, aggiungendo mappe di base
leaflet() %>%
    addProviderTiles(providers$Esri.WorldImagery, group = "Esri World Imagery") %>%
    addProviderTiles(providers$CartoDB.Positron, group = "CartoDB Positron") %>%
    addProviderTiles(providers$OpenStreetMap, group = "OpenStreetMap") %>%
    addRasterRGB(
        rgb_image_raster,
        r = 1, g = 2, b = 3,
        maxBytes = 4 * 1024 * 1024,
        group = "Original RGB"
    ) %>%
    addRasterRGB(
        superpixel_rast_rgb,
        r = 1, g = 2, b = 3,
        maxBytes = 4 * 1024 * 1024,
        group = "Superpixel RGB"
    ) %>%
    addLayersControl(
        baseGroups = c("Esri World Imagery", "CartoDB Positron", "OpenStreetMap"),
        overlayGroups = c("Original RGB", "Superpixel RGB"),
        options = layersControlOptions(collapsed = FALSE)
    )









































# Carica le librerie necessarie
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed])
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c("terra", "mmand", "leaflet", "leafem", "htmlwidgets", "png", "magick", "raster")
check_and_install(required_packages)

library(terra)
library(mmand)
library(leaflet)
library(leafem)
library(htmlwidgets)
library(png)
library(magick)
library(raster)

# Imposta la working directory (modifica il percorso secondo necessitÃ )
setwd("C:/composite")

# Carica il raster multibanda
img_84 <- rast("ritaglino.tif")

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# Calcola gli indici NDVI, MNDWI e NDBI
ndvi_1984 <- (l1984[[4]] - l1984[[3]]) / (l1984[[4]] + l1984[[3]])
mndwi_1984 <- (l1984[[2]] - l1984[[5]]) / (l1984[[2]] + l1984[[5]])
ndbi_1984 <- (l1984[[5]] - l1984[[4]]) / (l1984[[5]] + l1984[[4]])

# Crea lo stack con bande e indici
stack_1984 <- c(l1984, ndvi_1984, mndwi_1984, ndbi_1984)

# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(stack_1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione del raster
full_pca1 <- rep(NA, ncell(stack_1984[[1]]))
full_pca2 <- rep(NA, ncell(stack_1984[[1]]))
full_pca3 <- rep(NA, ncell(stack_1984[[1]]))

full_pca1[!is.na(values(stack_1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(stack_1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(stack_1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(stack_1984)
ext(pca_rast2) <- ext(stack_1984)
ext(pca_rast3) <- ext(stack_1984)

# Crea lo stack delle componenti PCA
pca_stack <- c(pca_rast1, pca_rast2, pca_rast3)

# Parametro per la smussatura gaussiana
gaussian_sigma <- 1.5

# Applica la smussatura gaussiana a ciascuna componente
smoothed_matrix1 <- gaussianSmooth(
    matrix(full_pca1, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE),
    sigma = gaussian_sigma
)
smoothed_matrix2 <- gaussianSmooth(
    matrix(full_pca2, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE),
    sigma = gaussian_sigma
)
smoothed_matrix3 <- gaussianSmooth(
    matrix(full_pca3, nrow = nrow(stack_1984[[1]]), ncol = ncol(stack_1984[[1]]), byrow = TRUE),
    sigma = gaussian_sigma
)

# Converti le matrici smussate in SpatRaster
smoothed_rast1 <- rast(smoothed_matrix1)
smoothed_rast2 <- rast(smoothed_matrix2)
smoothed_rast3 <- rast(smoothed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini smussate
ext(smoothed_rast1) <- ext(stack_1984)
ext(smoothed_rast2) <- ext(stack_1984)
ext(smoothed_rast3) <- ext(stack_1984)

# Crea lo stack delle componenti smussate
smoothed_stack <- c(smoothed_rast1, smoothed_rast2, smoothed_rast3)

# Funzione per scalare i valori di un layer tra 0 e 255
scale_to_255 <- function(raster_layer) {
    min_val <- minmax(raster_layer)[1]  # Minimo
    max_val <- minmax(raster_layer)[2]  # Massimo
    
    # Formula per scalare i valori nel range [0, 255]
    scaled_values <- 255 * (values(raster_layer) - min_val) / (max_val - min_val)
    
    # Reintegra i valori scalati nel raster
    values(raster_layer) <- scaled_values
    return(raster_layer)
}

# Applica la funzione di scaling a ciascun layer del raster smussato
scaled_r1 <- scale_to_255(smoothed_stack[[1]])
scaled_r2 <- scale_to_255(smoothed_stack[[2]])
scaled_r3 <- scale_to_255(smoothed_stack[[3]])

# Combina i layer scalati in un unico SpatRaster
scaled_rgb_image <- c(scaled_r1, scaled_r2, scaled_r3)

# Verifica i nuovi valori minimi e massimi
print(minmax(scaled_rgb_image))

# **Conversione da SpatRaster a RasterBrick**

# Definisci un percorso temporaneo per salvare il raster
temp_file <- tempfile(fileext = ".tif")

# Scrivi il SpatRaster su disco come GeoTIFF
writeRaster(scaled_rgb_image, temp_file, overwrite = TRUE)

# Importa il GeoTIFF come RasterBrick
rgb_image_raster_brick <- brick(temp_file)

# Rimuovi il file temporaneo se non necessario
# file.remove(temp_file)  # Puoi decomentare questa linea per eliminare il file dopo la lettura

# Assicurati che il CRS sia impostato correttamente
crs(rgb_image_raster_brick) <- crs(img_84)

# **Visualizzazione con Leaflet**

# Crea la mappa Leaflet
leaflet_map <- leaflet() %>%
    addProviderTiles(providers$Esri.WorldImagery, group = "Esri World Imagery") %>%
    addProviderTiles(providers$CartoDB.Positron, group = "CartoDB Positron") %>%
    addProviderTiles(providers$OpenStreetMap, group = "OpenStreetMap") %>%
    addRasterRGB(
        rgb_image_raster_brick,
        r = 1, g = 2, b = 3,
        group = "PCA RGB",
        opacity = 0.8
    )

# **Opzionale: Aggiungere ulteriori layer o elaborazioni (es. KMeans)**

# Se desideri aggiungere ulteriori elaborazioni come la segmentazione con KMeans,
# puoi integrare il tuo flusso di lavoro originale qui.
# Per questo esempio, consideriamo solo l'immagine PCA RGB.

# Aggiungi controlli dei layer
leaflet_map <- leaflet_map %>%
    addLayersControl(
        baseGroups = c("Esri World Imagery", "CartoDB Positron", "OpenStreetMap"),
        overlayGroups = c("PCA RGB"),
        options = layersControlOptions(collapsed = FALSE)
    ) %>%
    addLegend(position = "bottomright",
              colors = c("red", "green", "blue"),
              labels = c("Red", "Green", "Blue"),
              title = "PCA RGB Channels",
              opacity = 0.8)

# **Visualizza la mappa**
leaflet_map




























SMUSSATURA GAUSSIANA
# -------------------------------------------
# 1. Caricamento e installazione delle librerie
# -------------------------------------------
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed], dependencies = TRUE)
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c(
    "terra", "mmand", "kohonen", "NbClust", "stats", "RColorBrewer"
)
check_and_install(required_packages)

# Carica le librerie
library(terra)
library(mmand)
library(kohonen)
library(NbClust)
library(stats)
library(RColorBrewer)

# -------------------------------------------
# 2. Impostazione della directory di lavoro e caricamento del raster
# -------------------------------------------
# Imposta la working directory (modifica il percorso secondo necessitÃ )
setwd("C:/composite")  # Modifica questo percorso se necessario

# Carica il raster multibanda
img_84 <- rast("ritaglino.tif")  # Assicurati che il file esista nel percorso specificato

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# -------------------------------------------
# 3. Estrazione dei valori e PCA
# -------------------------------------------
# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(l1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione del raster
full_pca1 <- rep(NA, ncell(l1984[[1]]))
full_pca2 <- rep(NA, ncell(l1984[[1]]))
full_pca3 <- rep(NA, ncell(l1984[[1]]))

full_pca1[!is.na(values(l1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(l1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(l1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(l1984[[1]]), ncol = ncol(l1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(l1984[[1]]), ncol = ncol(l1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(l1984[[1]]), ncol = ncol(l1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(l1984)
ext(pca_rast2) <- ext(l1984)
ext(pca_rast3) <- ext(l1984)

# Crea lo stack delle componenti PCA
pca_stack <- c(pca_rast1, pca_rast2, pca_rast3)

# -------------------------------------------
# 4. Smussatura gaussiana delle componenti PCA
# -------------------------------------------
# Parametro per la smussatura gaussiana
gaussian_sigma <- 1.5

# Applica la smussatura gaussiana a ciascuna componente
smoothed_matrix1 <- gaussianSmooth(
    matrix(full_pca1, nrow = nrow(l1984[[1]]), 
           ncol = ncol(l1984[[1]]), byrow = TRUE),
    sigma = gaussian_sigma
)
smoothed_matrix2 <- gaussianSmooth(
    matrix(full_pca2, nrow = nrow(l1984[[1]]), 
           ncol = ncol(l1984[[1]]), byrow = TRUE),
    sigma = gaussian_sigma
)
smoothed_matrix3 <- gaussianSmooth(
    matrix(full_pca3, nrow = nrow(l1984[[1]]), 
           ncol = ncol(l1984[[1]]), byrow = TRUE),
    sigma = gaussian_sigma
)

# Converti le matrici smussate in SpatRaster
smoothed_rast1 <- rast(smoothed_matrix1)
smoothed_rast2 <- rast(smoothed_matrix2)
smoothed_rast3 <- rast(smoothed_matrix3)

# Imposta l'estensione e la risoluzione delle immagini smussate
ext(smoothed_rast1) <- ext(l1984)
ext(smoothed_rast2) <- ext(l1984)
ext(smoothed_rast3) <- ext(l1984)

# Crea lo stack delle componenti smussate
smoothed_stack <- c(smoothed_rast1, smoothed_rast2, smoothed_rast3)

# -------------------------------------------
# 5. Calcolo dei neuroni e configurazione della griglia SOM
# -------------------------------------------
# Calcola il numero totale di neuroni suggerito dalla formula
n <- sum(!is.na(values(smoothed_stack[[1]])))  # Numero totale di pixel non NA
neurons <- 5 * sqrt(n)
cat("Numero suggerito di neuroni:", round(neurons), "\n")

# Suggerisci una configurazione di griglia approssimata
x_dim <- round(sqrt(neurons))
y_dim <- round(neurons / x_dim)
cat("Dimensioni della griglia suggerite:", x_dim, "x", y_dim, "\n")

# -------------------------------------------
# 6. Applicazione del modello SuperSOM
# -------------------------------------------
# Estrazione e normalizzazione dei valori RGB
rgb_values <- as.data.frame(values(smoothed_stack))
rgb_values <- rgb_values[complete.cases(rgb_values), ]  # Rimuovi NA
rgb_values_norm <- scale(rgb_values)  # Normalizza i dati

# Definizione della griglia SOM
som_grid <- somgrid(xdim = x_dim, ydim = y_dim, topo = "hexagonal")  # Usa le dimensioni calcolate

# Allena il modello SuperSOM
  # Per riproducibilitÃ 
supersom_model <- supersom(
    list(rgb_values_norm), # Lista con input multipli; nel nostro caso Ã¨ uno solo
    grid = som_grid,
    rlen = 100, # Numero di iterazioni
    cores = -1
)

# -------------------------------------------
# 7. Determinazione del numero ottimale di cluster con NbClust
# -------------------------------------------
# Ottieni i codici della SOM dal modello SuperSOM
som_values <- supersom_model$codes[[1]]  # Codici dei neuroni SOM

# Usa NbClust per determinare il numero ottimale di cluster
  # Per riproducibilitÃ 
nbclust_result <- NbClust(
    data = som_values,       # Usa i codici della SOM
    diss = NULL,             # Usa i dati direttamente
    distance = "euclidean",  # Distanza euclidea
    min.nc = 2,              # Numero minimo di cluster
    max.nc = 10,             # Numero massimo di cluster
    method = "kmeans",       # Metodo di clustering K-means
    index = "all"            # Usa tutti i criteri di validazione
)

# Trova il numero ottimale di cluster dalla moda dei risultati
optimal_clusters <- as.numeric(names(which.max(table(nbclust_result$Best.nc[1, ]))))

# Stampa il numero ottimale di cluster
cat("Il numero ottimale di cluster secondo NbClust Ã¨:", optimal_clusters, "\n")

# -------------------------------------------
# 8. Applicazione di KMeans e mappatura dei cluster
# -------------------------------------------
# Applica KMeans ai codici della SOM
kmeans_result <- kmeans(som_values, centers = optimal_clusters)

# Etichette dei cluster per ciascun neurone
som_cluster_labels <- kmeans_result$cluster

# Mappa i cluster ai pixel originali
pixel_clusters <- supersom_model$unit.classif  # Ogni pixel ha un riferimento a un neurone
pixel_cluster_labels <- som_cluster_labels[pixel_clusters]

# Crea un raster vuoto con la stessa estensione e risoluzione di smoothed_stack
cluster_raster <- rast(smoothed_stack[[1]])

# Inizializza i valori del raster con NA
values(cluster_raster) <- NA

# Associa i cluster ai pixel usando pixel_cluster_labels
values(cluster_raster)[!is.na(values(smoothed_stack[[1]]))] <- pixel_cluster_labels

# Verifica che i valori siano stati assegnati correttamente
print(summary(values(cluster_raster)))

# -------------------------------------------
# 9. Visualizzazione del raster dei cluster
# -------------------------------------------
# Visualizza il raster usando la funzione plot di base
plot(
    cluster_raster,
    main = paste("Cluster da NbClust e KMeans (", optimal_clusters, " clusters)", sep = ""),
    col = rainbow(optimal_clusters),
    axes = TRUE,
    legend = TRUE
)

# -------------------------------------------
# Fine dello script
# -------------------------------------------




















OPENING

# -------------------------------------------
# 1. Caricamento e installazione delle librerie
# -------------------------------------------
check_and_install <- function(packages) {
    installed <- packages %in% rownames(installed.packages())
    if (any(!installed)) {
        install.packages(packages[!installed], dependencies = TRUE)
    }
    invisible(lapply(packages, library, character.only = TRUE))
}

required_packages <- c(
    "terra", "mmand", "kohonen", "NbClust", "stats", "RColorBrewer"
)
check_and_install(required_packages)

# Carica le librerie
library(terra)
library(mmand)
library(kohonen)
library(NbClust)
library(stats)
library(RColorBrewer)

# -------------------------------------------
# 2. Impostazione della directory di lavoro e caricamento del raster
# -------------------------------------------
# Imposta la working directory (modifica il percorso secondo necessitÃ )
setwd("C:/composite")  # Modifica questo percorso se necessario

# Carica il raster multibanda
img_84 <- rast("ritaglio.tif")  # Assicurati che il file esista nel percorso specificato

# Seleziona le bande necessarie (B1, B2, B3, B4, B5, B7)
l1984 <- img_84[[c(1, 2, 3, 4, 5, 6)]]

# -------------------------------------------
# 3. Estrazione dei valori e PCA
# -------------------------------------------
# Estrai i valori dal raster stack come dataframe e rimuovi i valori NA
values_stack_1984 <- as.data.frame(values(l1984))
values_stack_1984_non_na <- values_stack_1984[complete.cases(values_stack_1984), ]

# PCA: esegui la PCA sullo stack e seleziona le prime tre componenti principali
pca_result <- prcomp(values_stack_1984_non_na, center = TRUE, scale. = TRUE)
pca_values <- pca_result$x[, 1:3]  # Seleziona le prime tre componenti

# Reintegra i pixel NA nella matrice della PCA per mantenere la dimensione del raster
full_pca1 <- rep(NA, ncell(l1984[[1]]))
full_pca2 <- rep(NA, ncell(l1984[[1]]))
full_pca3 <- rep(NA, ncell(l1984[[1]]))

full_pca1[!is.na(values(l1984[[1]]))] <- pca_values[, 1]
full_pca2[!is.na(values(l1984[[1]]))] <- pca_values[, 2]
full_pca3[!is.na(values(l1984[[1]]))] <- pca_values[, 3]

# Converti ciascuna componente in SpatRaster
pca_rast1 <- rast(matrix(full_pca1, nrow = nrow(l1984[[1]]), ncol = ncol(l1984[[1]]), byrow = TRUE))
pca_rast2 <- rast(matrix(full_pca2, nrow = nrow(l1984[[1]]), ncol = ncol(l1984[[1]]), byrow = TRUE))
pca_rast3 <- rast(matrix(full_pca3, nrow = nrow(l1984[[1]]), ncol = ncol(l1984[[1]]), byrow = TRUE))

# Imposta l'estensione per mantenere la risoluzione originale
ext(pca_rast1) <- ext(l1984)
ext(pca_rast2) <- ext(l1984)
ext(pca_rast3) <- ext(l1984)

# Crea lo stack delle componenti PCA
pca_stack <- c(pca_rast1, pca_rast2, pca_rast3)

# -------------------------------------------
# 4. Apertura Morfologica delle componenti PCA
# -------------------------------------------
# Definisci il kernel strutturante
structuring_element <- shapeKernel(c(3, 3), type = "disc")

# Applica l'apertura morfologica a ciascuna componente
opened_matrix1 <- morph(
    matrix(full_pca1, nrow = nrow(l1984[[1]]), 
           ncol = ncol(l1984[[1]]), byrow = TRUE),
    structuring_element,
    operation = 'opening'
)

opened_matrix2 <- morph(
    matrix(full_pca2, nrow = nrow(l1984[[1]]), 
           ncol = ncol(l1984[[1]]), byrow = TRUE),
    structuring_element,
    operation = 'opening'
)

opened_matrix3 <- morph(
    matrix(full_pca3, nrow = nrow(l1984[[1]]), 
           ncol = ncol(l1984[[1]]), byrow = TRUE),
    structuring_element,
    operation = 'opening'
)

# Converti le matrici aperte in SpatRaster
opened_rast1 <- rast(opened_matrix1)
opened_rast2 <- rast(opened_matrix2)
opened_rast3 <- rast(opened_matrix3)

# Imposta l'estensione e la risoluzione delle immagini aperte
ext(opened_rast1) <- ext(l1984)
ext(opened_rast2) <- ext(l1984)
ext(opened_rast3) <- ext(l1984)

# Crea lo stack delle componenti aperte
opened_stack <- c(opened_rast1, opened_rast2, opened_rast3)

# -------------------------------------------
# 5. Calcolo dei neuroni e configurazione della griglia SOM
# -------------------------------------------
# Calcola il numero totale di neuroni suggerito dalla formula
n <- sum(!is.na(values(opened_stack[[1]])))  # Numero totale di pixel non NA
neurons <- 5 * sqrt(n)
cat("Numero suggerito di neuroni:", round(neurons), "\n")

# Suggerisci una configurazione di griglia approssimata
x_dim <- round(sqrt(neurons))
y_dim <- round(neurons / x_dim)
cat("Dimensioni della griglia suggerite:", x_dim, "x", y_dim, "\n")

# -------------------------------------------
# 6. Applicazione del modello SuperSOM
# -------------------------------------------
# Estrazione e normalizzazione dei valori delle componenti aperte
opened_values <- as.data.frame(values(opened_stack))
opened_values <- opened_values[complete.cases(opened_values), ]  # Rimuovi NA
opened_values_norm <- scale(opened_values)  # Normalizza i dati

# Definizione della griglia SOM
som_grid <- somgrid(xdim = x_dim, ydim = y_dim, topo = "hexagonal")  # Usa le dimensioni calcolate

# Allena il modello SuperSOM
# Per riproducibilitÃ 
set.seed(123)  # Imposta un seed per la riproducibilitÃ 
supersom_model <- supersom(
    list(opened_values_norm), # Lista con input multipli; nel nostro caso Ã¨ uno solo
    grid = som_grid,
    rlen = 100, # Numero di iterazioni
    cores = -1
)

# -------------------------------------------
# 7. Determinazione del numero ottimale di cluster con NbClust
# -------------------------------------------
# Ottieni i codici della SOM dal modello SuperSOM
som_values <- supersom_model$codes[[1]]  # Codici dei neuroni SOM

# Usa NbClust per determinare il numero ottimale di cluster
# Per riproducibilitÃ 
set.seed(123)  # Imposta un seed per la riproducibilitÃ 
nbclust_result <- NbClust(
    data = som_values,       # Usa i codici della SOM
    diss = NULL,             # Usa i dati direttamente
    distance = "euclidean",  # Distanza euclidea
    min.nc = 2,              # Numero minimo di cluster
    max.nc = 10,             # Numero massimo di cluster
    method = "kmeans",       # Metodo di clustering K-means
    index = "all"            # Usa tutti i criteri di validazione
)

# Trova il numero ottimale di cluster dalla moda dei risultati
optimal_clusters <- as.numeric(names(which.max(table(nbclust_result$Best.nc[1, ]))))

# Stampa il numero ottimale di cluster
cat("Il numero ottimale di cluster secondo NbClust Ã¨:", optimal_clusters, "\n")

# -------------------------------------------
# 8. Applicazione di KMeans e mappatura dei cluster
# -------------------------------------------
# Applica KMeans ai codici della SOM
set.seed(123)  # Imposta un seed per la riproducibilitÃ 
kmeans_result <- kmeans(som_values, centers = optimal_clusters)

# Etichette dei cluster per ciascun neurone
som_cluster_labels <- kmeans_result$cluster

# Mappa i cluster ai pixel originali
pixel_clusters <- supersom_model$unit.classif  # Ogni pixel ha un riferimento a un neurone
pixel_cluster_labels <- som_cluster_labels[pixel_clusters]

# Crea un raster vuoto con la stessa estensione e risoluzione di opened_stack
cluster_raster <- rast(opened_stack[[1]])

# Inizializza i valori del raster con NA
values(cluster_raster) <- NA

# Associa i cluster ai pixel usando pixel_cluster_labels
values(cluster_raster)[!is.na(values(opened_stack[[1]]))] <- pixel_cluster_labels

# Verifica che i valori siano stati assegnati correttamente
print(summary(values(cluster_raster)))

# -------------------------------------------
# 9. Visualizzazione del raster dei cluster
# -------------------------------------------
# Definisci una palette di colori
cluster_colors <- brewer.pal(max(optimal_clusters, 3), "Set3")  # Assicurati di avere abbastanza colori

# Visualizza il raster usando la funzione plot di base
plot(
    cluster_raster,
    main = paste("Cluster da NbClust e KMeans (", optimal_clusters, " cluster)", sep = ""),
    col = cluster_colors,
    axes = TRUE,
    legend = TRUE
)

# -------------------------------------------
# Fine dello script
# -------------------------------------------
